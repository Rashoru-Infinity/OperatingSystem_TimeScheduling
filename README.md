# OperatingSystem_TimeScheduling
ターンアラウンドタイムについて簡単に実験を行い、簡単に考察しました。

# 実験
今回は10000個のプロセスの設定にそれぞれ乱数を使い、プログラムに渡すようにしました。

ただし、プログラムが正しく、また、短時間で終わる入力にするため、すべてのテストケースに対して以下のルールを適用してプロセスを生成しました。

  ・プロセスの所要時間は1~11

  ・到着時間は 0 ~ (プロセスの個数) x 10

  ・プロセスの期限は 1 ~ (プロセスの個数) x 25 (期限については守れないケースも出てきますが今回は無視しました)

これらのルールとは別に各テストケースでは様々なルールを適用してプロセスを生成しています。

\~DefaultTestCase.txt\~

  ・Defaultクラスから生成

  ・優先度は0 ~ 10000に設定

  ・タイムスライスは5に設定

\~BestCase_Priority.txt\~

  ・BestCasePriorityクラスから生成

  ・優先度が所要時間に比例

  ・タイムスライスは5に設定

\~WorstCasePriority.txt\~

  ・WorstCasePriorityクラスから生成

  ・優先度が所要時間に反比例

  ・タイムスライスは5に設定

\~LongRoundRobin.txt\~

  ・LongRoundRobinクラスから生成

  ・優先度は0 ~ 10000に設定

  ・タイムスライスを10に設定

\~ShortRoundRobin.txt\~

  ・ShortRoundRobinクラスから生成

  ・優先度は0 ~ 10000に設定

  ・タイムスライスは1に設定

# 結果

テストケースと結果についてはTestCase_and_Result内の対応する各ディレクトリをご覧ください。

また、defaultのテストケースの出力を絞って各スケジューリングの分散の計算を行った結果が以下になります。
|順位|スケジューリング|分散|
|---|---|---|
|1|FCFS|79.79816636|
|2|RoundRobin|81.86887511|
|3|Priority|84.27836156|
|4|SPT|88.95146631|
|5|Deadline|97.02839119|

結果から以下の傾向が見られました。

・横取りのあるスケジューリング(DeadlineとRoundRobin)は応答性が低い

・所要時間が短いプロセスを優先すると応答性が高くなる

# 考察

応答性は待ち状態のプロセスが多いと落ちます。そのため、横取りのあるスケジューリングは各プロセスが中々終わらず、応答性が落ちるのではないかと考えます。

また、所要時間についても、長いものを処理するとき、待ち状態のプロセスがたまってしまうことで、大量のプロセスの応答時間が伸びてしまいます。こうしたことからSPTのようなスケジューリングでは応答性が高くなるのではないかと考えました。

待ち時間の分散についてですが、FCFSは先に到着したプロセスから処理するために小さくなると考えられます。

RoundRobinは待ち状態のプロセスを一定時間ごとに切り替えるので、長時間待たされ続けるプロセスが少ないために分散が小さいことが挙げられます。タイムスライスを小さくすれば、さらに分散が小さくなるでしょう。

Priorityについては優先度自体に乱数が使われており、調整もしていないので、実験毎に分散が大きく変動すると思われます。

SPTは処理時間が短いものが先に処理され、長いものは後回しなため、分散が大きくなるのは明らかです。

Deadlineはプロセスの到着した順番を無視するので、大きくなっていると考えられます。

分散が小さければ、プロセスの待ち時間に幅が出にくくなります。

使い手の好み次第では応答性より応答時間の幅の少なさが重要になるのではないかと思います。
